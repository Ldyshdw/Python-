## $$数算课程大作业$$

### 期末笔试知识复习

1. $逻辑结构$

   指逻辑数据元素之间的逻辑关系的组织方式，与存储结构不同。其包括：集合结构，线性结构与非线性结构。线性结构：线性表，栈，队列，串                                                                             非线性结构：树，图

2. $存储结构$​

   指数据的具体存储形式，实际的组织和排列方式。存储密度 < 1。信息量 / 存储量 。主要包括：顺序，链式，索引和散列四种结构。

   顺序结构：查找快O1，增删慢On。有顺序表和C语言中基于数组存在的栈和队列。以后简称S和Q。

   链式结构：增删快O1，查找慢On，题目喜欢问删除指定元素的时间复杂度，包含找和删，所以是On。有单链表，双链表和循环链表。

   索引结构：通过索引表找到数据元素，查找效率高，增删复杂，索引表需要额外内存和维护。例如B树和B+树。

   散列结构：通过散列函数通过key找地址，实现快速查找和存储。例如：哈希表。会出现地址冲突，通过线性探测法，二次探测法等方法解决冲突。

3. $常考题目$

   一个逻辑结构有多种类型的存储结构，不同类型的存储结构会影响数据处理效率，两者都会影响算的快慢，但是计算结果不影响。

   基于顺序结构的逻辑结构不一定是线性结构，例如堆。

4. $线性表$

   List ：零个或者多个数据元素的有限序列。有唯一头元素和尾元素，头元素只有后继，尾元素只有前驱。这个也会考察概念。Python 中的增删查找均为On，len append pop index 修改都是 O1

5. $链表$

   单链表：数据域，指针域。判断单链表是否为空，Q.head == None 。链表中第一个结点的存储位置叫做头指针。有时为了方便对对链表进行操作，会在单链表的第一个结点前附设一个节点，称为头结点，此时头指针指向的结点就是头结点。

   双链表 (dll)：指针域两个，一个指向前驱一个指向后继。

   循环链表：将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。

6. $堆$ 常考内容

   实现方式：按完全二叉树的顺序存储方式把元素存储在一个一维数组中，满足根节点值大于（小于）所有子节点值

   初始化：对分支节点从下往上依次向下冒泡调整，时间复杂度为$O(n)$

   插入：将元素插入最后一位，再进行向上冒泡，时间复杂度为$O(logn)$

   删除：删除堆的根节点，将最后一个节点补到根节点位置，再对根节点进行向下冒泡，时间复杂度为$O(logn)$

   建堆：n 。插入: log n。删除：log n，查找 n 。

7. $循环队列$​ 常考内容

   用长度为$n$的数组实现，认为rear指向末端元素下一个空位（新元素插入位置）时：

   队空条件为：$rear==front$

   队列长度为：$length=(rear-front+n)\%n$

   队满：$(rear-front+1)\%n==0$

8. $排序$​​ 最难最爱考的部分
   $$
   \begin{array}{|c|c|c|c|c|c|c|p{6cm}|}\hline     名称 & 最佳 & 平均 & 最差 & 内存 & 稳定性 & 方法 & 其他备注 \\\hline    冒泡排序 & n & n^2 & n^2 & 1 & 是 & 交换 & 代码量极小 \\\hline    选择排序 & n^2 & n^2 & n^2 & 1 & 否 & 选择 & 当使用链表代替交换时，稳定,多了O(n)额外空间 \\\hline    快速排序 & nlogn & nlogn & n^2 & logn& 否 & 分区 & 通常原地进行，栈空间为O(logn) \\\hline    归并排序 & nlogn & nlogn & nlogn & n & 是 & 归并 & 高度可并行化(可优化至O(log n))\\\hline    插入排序 & n & n^2 & n^2 & 1 & 是 & 插入 & 最坏有d个逆序对，时间复杂度为O(n + d) \\\hline    希尔排序 & nlogn & n^{4/3}& n^{3/2}& 1 & 否 & 插入 & 代码量小 \\\hline    堆排序 & nlogn & nlogn & nlogn & 1 & 否 & 选择 & \\\hline\end{array}
   $$
   不稳定的：选择，快速，希尔，堆

   最占内存的：归并，其次快排

   冒泡排序：稳定，On2，最佳 n 交换

   选择排序：不稳定，On2，最佳 On2 找最大交换

   快排：不稳定，nlogn 最佳 nlogn  双指针pivot 向中间找，直到R与L相遇，R换大的，L是换小的

   归并：稳定，nlogn 最佳 nlogn 

   插入排序：稳定，n2 最佳n 

   希尔：交换 不稳定 n2

   堆：不稳定 nlogn (堆操作除了建堆和查找是n 其余都是log n)

9. $二叉树的二级结论$

   深度高度看定义，不说就是根节点深度 == 1 高度从 0 开始。层数是最客观的指标。考试选择题用赋值法，填空题可以用归纳法。

   1）第$i$层最个多$2^i$个结点（层数从0开始）
   2）高为$h$的二叉树结点总数最多$2^{h+1}-1$
   3）结点数为$n$的树，边的数目为$n-1$
   4）$n$个结点的非空二叉树至少有$$\lceil log_2(n+1) \rceil$$层结点，即高度至少为 $\lceil log_2(n+1) \rceil - 1$
   5）在任意一棵二叉树中，若叶子结点（度为0）的个数为$n_0$，度为2的结点个数为$n_2$，则
   $$
   \begin{eqnarray}
   	n_0+n_1+n_2-1&=&边数\\
   	n_1+2\ n_2&=&边数\\
   	\Rightarrow n_2&=&n_0-1
   \end{eqnarray}
   $$
   6）非空满二叉树叶结点数目等于分支结点数目加1。

   >   ​	在满二叉树中，我们把有子节点的节点称为分支节点。每个分支节点都会产生两个新的叶节点。  
   >   ​	但是，当我们添加一个新的分支节点时，原来的一个叶节点会变成分支节点。所以，实际上只增加了一个叶节点。 

   ​		a）**完全二叉树**中度为1的结点数目为0个或1个

   ​				结合$n_2=n_0-1$可以得到$\Rightarrow$有$n$个结点的完全二叉树有$\lfloor (n+1)/2 \rfloor$个叶结点

   ​		c）有$n$个叶结点的完全二叉树有$2n$或$2n-1$个结点（两种都可以构建）

   ​		d）有$n$个结点的非空完全二叉树的高度为$\lceil log_2(n+1)\rceil - 1$      （层数为$\lceil log_2(n+1)\rceil $）

   对一个度为$2$的森林 ，叶子结点总数为$L$，度数为$2$结点总个数为$N$，那么树的个数为$L-N$

   

10. $树的存储$​

    双亲表示法，孩子链表表示法，孩子兄弟表示法 

    顺序结构，链式结构

11. $BST与Huffman$

    删：将删除的节点的值替换为左子树最大值或右子树最小值

    增：递归搜索，新增的节点一定是叶子节点

    <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240309111247017.png" alt="image-20240309111247017" style="zoom: 50%;" />

    真正存储的数据都在叶子结点

    建树：使用$heapq$重复合并权值最小的两个节点（或子树），直到所有节点都合并为一棵树为止

    带权外部路径长度：叶节点数值×节点深度（从0开始）考察算。

    

12. $图的一些基本知识$

    完全图：任意两顶点之间都有边。

    连通图：无向图，图中任意两点之间都是联通的

    连通分量：无向图中的极大联通子图

    极小连通分量：无向图中的最少边数的联通子图

    强连通分量：有向图中的极大强连通子图

    生成树：包含全部顶点的一个极小连通子图

    强连通分支：局部极大强连通子图，一个图中可能不止一个强连通分支

    有向图$D=(V,E)$的每个点位于且仅位于$D$的某个强连通分支中。这就是说，所有强连通分支包含所有顶点

    对任意一个连通的、无环的无向图，从图中移除任何一条边得到的图均不连通。

    ### $邻接表\&邻接矩阵\&相邻矩阵\&路径矩阵$

    **邻接表**与邻接入边表（或称逆邻接表）：稀疏图适合

    <img src="https://raw.githubusercontent.com/heiheiha798/spring-cs201-yangtianjian/main/img/image-20240616143750986.png" alt="image-20240616143750986" style="zoom:60%;" />

    **邻接矩阵**：$n\times n$二维数组 密集图适合
    $$
    \begin{vmatrix} 
    	0 & 7 & \infty & 4 & 2 \\ 
    	7 & 0 & 9 & 1 & 5 \\ 
    	\infty & 9 & 0 & 3 & \infty \\ 
    	4 & 1 & 3 & 0 & 10 \\ 
    	2 & 5 & \infty & 10 & 0 \\ 
    \end{vmatrix}
    $$
    **相邻矩阵 $(A)$**：是一个 $n \times n$ 的矩阵，$A_{ij}$ 的值为1表示 $i$ 和 $j$ 节点之间有边，0表示没有边

    **路径矩阵**：相邻矩阵的$m$次幂$ A^m $的 $i$ 行 $j$ 列的值表示 $i$ 和 $j$ 节点之间的路径的数量。如果该元素不为零，说明存在长度为$m$的路径。

    题目中常考给定图从0出发bfs和dfs。

13. $图中的难点$​

    

    ### $Dijkstra$

    带权BFS，用以求解图中特定两点间最短距离

    Dijkstra算法的核心思想是贪心算法。从起始节点开始，逐步扩展到达图中所有其他节点的最短路径。算法维护两组节点集合：已经找到最短路径的节点集合和还没有找到最短路径的节点集合。初始时，起始节点的最短路径值设为0，其他所有节点的最短路径值设为无穷大。算法重复以下步骤直到所有节点的最短路径都被找到：

    1. 从还没有找到最短路径的节点集合中选择一个与起始节点最短距离最小的节点。
    2. 更新该节点相邻的节点的最短路径值：如果通过该节点到达相邻节点的路径比当前记录的路径更短，就更新这个最短路径值。
    3. 将该节点移动到已经找到最短路径的节点集合中。
    4. 重复上述步骤，直到所有节点的最短路径都被找到。

    对负权边失效$\Rightarrow$贪心策略不再适用（$Prim$​算法可以负权）

    ### $最小生成树$

    在一给定的**无向图**$\ G = (V, E)$ 中，$(u, v)$ 代表连接顶点$u $与顶点$ v $的边，而$ w(u, v) $代表此的边权重，若存在$ T $为$ E $的子集（即）且为无循环图，使得$ w(T) $最小，则此$ T $为$ G $的最小生成树。最小生成树其实是最小权重生成树的简称。

    $Prim$算法&$Kruskal$算法：

    - **Prim 算法（适合稠密图）**：
      - 邻接矩阵 + 简单数组：$O(V^2)$
      - 邻接表 + 二叉堆：$O(Elog V)$
      - 邻接表 + 斐波那契堆：$O(Vlog V + E)$

    - **Kruskal 算法（适合稀疏图）**
      - 并查集优化：$O(Elog V)$

    

14. $查找$

    ### $KMP$

    #### $前缀函数$

    定义：给定一个长度为$n$的字符串$s$，其前缀函数被定义为一个长度为$n$的数组$\pi$。其中$\pi[i]$的定义是：

    1. 如果子串$s[0…i]$有一对相等的真前缀与真后缀：$s[0…k-1]$和$s[i-(k-1)…i]$，那么$\pi[i]$就是这个相等的真前缀（或者真后缀，因为它们相等）的长度，也就是$\pi[i]=k$；
    2. 如果不止有一对相等的，那么$\pi[i]$就是其中最长的那一对的长度；
    3. 如果没有相等的，那么$\pi[i]=0$。

    简单来说$\pi[i]$就是，子串$s[0…i]$最长的相等的真前缀与真后缀的长度。

    用数学语言描述如下：
    $$
    \pi[i] = \max_{k=0..i} \{ k : s[0 \ldots k-1] = s[i-(k-1) \ldots i] \}
    $$
    特别地，规定$\pi[0]=0$。

    #### $例子$

    对于字符串 `abcabcd`

    $\pi[0]=0$，因为 `a` 没有真前缀和真后缀，根据规定为 0

    $\pi[1]=0$，因为 `ab` 无相等的真前缀和真后缀

    $\pi[2]=0$，因为 `abc` 无相等的真前缀和真后缀

    $\pi[3]=1$，因为 `abca` 只有一对相等的真前缀和真后缀：`a`，长度为 1

    $\pi[4]=2$，因为 `abcab` 相等的真前缀和真后缀只有 `ab`，长度为 2

    $\pi[5]=3$，因为 `abcabc` 相等的真前缀和真后缀只有 `abc`，长度为 3

    $\pi[6]=0$，因为 `abcabcd` 无相等的真前缀和真后缀

    同理可以计算字符串 `aabaaab` 的前缀函数为$[0,1,0,1,2,2,3]$。

    #### $Next数组$

    next数组用于存储模式字符串中每个位置之前（不包括此位置）的最大前缀长度，具体来说，next数组的含义如下：

    - 对于模式字符串的每一个位置 $i$，$next$数组的值$ next[i]$ 表示模式字符串中从位置$0$到位置 $i$ 的子串的最长前缀，它同时也是该子串的后缀。即，$next$数组中的每一个值是指前缀的长度。

    一种实操方法：$[-1]+$前缀数组$[:-1]$

    例：$aabcaabbaa$的$next$数组为$[-1,0,1,0,0,1,2,3,0,1]$

    #### $关于0开头还是-1开头$

    $-1$开头与$0$开头的next数组本质是一样的。实际上，以$0$开头的$next$数组就是以$-1$开头的$next$数组每一项加$1$得到的。出现这种情况的原因在于模式串起始的索引值：在程序中，一个数组的索引的起始值为$0$；然而在考试和书中给的模式串起始值是多从$1$开始。

    

    ### $分治与DP$

    #### $分治$

    分治算法通常将原问题分解为几个规模较小但类似于原问题的子问题，求解这些子问题，然后再合并这些子问题的解来建立原问题的解。

    注意：不必须要用递归。

    #### $DP$

    如果一个问题的最优解可以由其子问题的最优解有效地构造出来，那么称这个问题拥有**最优子结构(Optimal Substructure)**。最优子结构保证了动态规划中原问题的最优解可以由子问题的最优解推导而来。因此，一个问题必须拥有最优子结构，才能使用动态规划去解决。

    分治和动态规划都是将问题分解为子问题，然后合并子问题的解得到原问题的解。但是不同的是，分治法分解出的子问题是不重叠的，因此分治法解决的问题不拥有重叠子问题，而动态规划解决的问题拥有**重叠子问题**。
